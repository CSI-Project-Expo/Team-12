# Inventory Management System

A modern, browser-based inventory management solution designed to eliminate the common pain points of traditional desktop applications like Vyapar. Built for reliability, real-time collaboration, and guaranteed data consistency.

---

## üéØ Why This Project?

Traditional inventory management apps suffer from fundamental architectural limitations. This project reimagines inventory management from the ground up, solving critical problems that plague multi-user retail environments.

---

## ‚ú® Key Advantages Over Traditional Apps

### 1Ô∏è‚É£ **Zero Installation, Maximum Flexibility**

**The Problem with Traditional Apps:**
- Requires software installation on each device
- Tied to specific devices with licensing restrictions
- Storage and update management overhead
- Device switching creates friction and downtime

**Our Solution:**
- ‚úÖ **Runs directly in the browser** - no installation needed
- ‚úÖ **Access from any device** - desktop, tablet, or mobile
- ‚úÖ **Consistent experience** across all platforms
- ‚úÖ **Always up-to-date** - no manual updates required

> **Big Win:** Complete flexibility - manage your inventory from anywhere, on any device, instantly.

---

### 2Ô∏è‚É£ **Real-Time Multi-User Synchronization**

**The Problem with Traditional Apps:**
- Data sync delays between devices
- Temporary data mismatches during busy periods
- "Who updated last?" confusion
- Sync conflicts in multi-staff environments

**Our Solution:**
- ‚úÖ **Single source of truth** - one live system
- ‚úÖ **Instant updates** - everyone sees changes in real-time
- ‚úÖ **Zero sync lag** - no waiting for data to propagate
- ‚úÖ **Conflict-free collaboration** - built for teams

> **Big Win:** No more confusion about which data is current - everyone always sees the same information.

---

### 3Ô∏è‚É£ **Guaranteed Stock Accuracy - No Overselling**

**The Problem with Traditional Apps:**
- Sync timing creates race conditions
- Two simultaneous sales can briefly conflict
- Overselling risk during peak hours
- Stock counts can become inaccurate

**Our Solution:**
- ‚úÖ **Atomic stock checks** - sales allowed only if stock exists at that exact moment
- ‚úÖ **Concurrency control** - simultaneous sales handled safely
- ‚úÖ **Impossible to oversell** - guaranteed by system architecture
- ‚úÖ **Always accurate inventory** - no phantom stock

> **Big Win:** Stock correctness is mathematically guaranteed, not just "usually right."

---

### 4Ô∏è‚É£ **Transactional Integrity - All or Nothing**

**The Problem with Traditional Apps:**
- Billing, stock updates, and records are separate features
- Data can drift if sync fails or process is interrupted
- Ghost stock entries or missing bills
- Manual reconciliation required

**Our Solution:**
- ‚úÖ **Single atomic transaction:**
  ```
  Sale ‚Üí Stock Update ‚Üí Bill Generation ‚Üí Email
  ```
- ‚úÖ **Either all happen or none happen** - no partial states
- ‚úÖ **No mismatched records** - guaranteed consistency
- ‚úÖ **Zero reconciliation** - system maintains integrity automatically

> **Big Win:** Your books are always accurate - no ghost inventory or missing invoices.

---

### 5Ô∏è‚É£ **Complete Transparency & Accountability**

**The Problem with Traditional Apps:**
- Difficult to track who made changes
- Limited audit trail
- No clear history of stock adjustments
- Accountability gaps in multi-staff shops

**Our Solution:**
- ‚úÖ **Every action is logged** with user, timestamp, and details
- ‚úÖ **Complete audit trail:**
  - Sales transactions
  - Stock adjustments
  - User actions
  - System events
- ‚úÖ **Full accountability** - know exactly who did what and when
- ‚úÖ **Easy investigation** - trace any discrepancy to its source

> **Big Win:** Complete visibility into all operations - perfect for managing teams.

---

### 6Ô∏è‚É£ **Flexible & Customizable Workflows**

**The Problem with Traditional Apps:**
- Fixed, rigid workflows
- Your business must adapt to the software
- Feature overload with unnecessary complexity
- One-size-fits-all approach

**Our Solution:**
- ‚úÖ **Core rules-based design** - built around fundamental principles
- ‚úÖ **Adaptable workflows** - customize to your business needs
- ‚úÖ **Focused functionality** - correctness over feature bloat
- ‚úÖ **Clean, controllable system** - you're in charge

> **Big Win:** The system adapts to your business, not the other way around.

---

### 7Ô∏è‚É£ **Always Current - Zero Maintenance**

**The Problem with Traditional Apps:**
- Manual app updates required
- Version fragmentation across devices
- Old versions cause compatibility issues
- Users on different versions create problems

**Our Solution:**
- ‚úÖ **Browser-based** = always latest version automatically
- ‚úÖ **Zero user maintenance** - updates happen seamlessly
- ‚úÖ **No version conflicts** - everyone uses the same version
- ‚úÖ **Instant feature rollout** - new capabilities available immediately

> **Big Win:** Your team never worries about updates - the system is always current.

---

## üèóÔ∏è Architecture Highlights

- **Web-based architecture** for universal access
- **Real-time database synchronization** for instant updates
- **Transaction-based operations** for data integrity
- **Comprehensive audit logging** for accountability
- **Responsive design** for any device

---

## üöÄ Getting Started

### Prerequisites
- Modern web browser (Chrome, Firefox, Safari, Edge)
- Internet connection
- That's it! No installation required.

### Access
Simply navigate to the application URL in your browser and log in. Your inventory management system is ready to use.

---

## üéØ Perfect For

- **Retail shops** with multiple staff members
- **Warehouses** requiring real-time stock visibility
- **Multi-location businesses** needing centralized inventory
- **Growing businesses** that need flexibility and scalability
- **Any business** tired of sync issues and data inconsistencies

---

## üîí Security & Reliability

- Secure authentication and authorization
- Role-based access control
- Encrypted data transmission
- Automated backups
- Disaster recovery ready

---

## üìä Core Features

- **Inventory Management** - Add, update, and track products
- **Sales Processing** - Quick and accurate transaction handling
- **Bill Generation** - Automatic invoice creation
- **Stock Alerts** - Low stock notifications
- **Reporting** - Comprehensive business insights
- **Multi-user Support** - Team collaboration built-in
- **Audit Trails** - Complete action history

---

## ü§ù Contributing

Contributions are welcome! Please feel free to submit issues or pull requests.

---

## üìù License

[Specify your license here]

---

## üìß Support

For questions or support, please contact [your contact information]

---

## üåü The Bottom Line

This isn't just another inventory management system - it's a fundamental rethinking of how inventory should work in a modern, collaborative environment. By eliminating installation requirements, guaranteeing data consistency, and providing real-time visibility, we've created a system that just works - reliably, every time.

**No sync issues. No overselling. No confusion. Just accurate, real-time inventory management.**

---

## üíª Tech Stack

### Frontend
- **Next.js** - Modern React framework for production-grade applications

### UI / Design
- **shadcn/ui** - Beautiful, accessible component library

### Backend
- **Node.js / Express API** - Robust server-side architecture

### Database
- **MongoDB** - Flexible NoSQL database for scalable data management

---

## üé® Design Focus

### Retailer-Centric Approach
Our design philosophy prioritizes the retailer experience:

- **More attractive** - Premium, professional interface
- **More useful** - Feature-rich with business-critical tools
- **Easier to use** - Intuitive workflows designed for daily operations
- **Business-oriented model** - Built around real retailer needs

### User (Customer) Side UI
The customer interface is intentionally streamlined:

- **Simple and clean** - No unnecessary complexity
- **Attractive but minimal** - Focus on usability over flashiness
- **Easy to understand** - Intuitive for all users
- **Quick interactions** - Fast, efficient user experience

---

## üì± QR Code + OCR Based Flow

### Innovative Bill Processing
Our system combines QR code technology with OCR (Optical Character Recognition) for seamless transactions:

### How It Works

**1. Purchase & Data Generation**
- Items are purchased and MongoDB generates a unique ID
- Bill data is saved in MongoDB
- The saved data is converted into a string
- That string is encoded into a QR code / barcode

**2. User Options**
Users can interact with their bills in two ways:
- **Upload a printed bill** - Take a photo and upload
- **Use inbuilt camera scanner** - Scan directly in the app

**3. OCR Processing**
- OCR extracts bill details from the image
- Data is automatically parsed and validated
- Information is ready for retailer verification

**4. Retailer Interaction**
- User shows the QR code to the retailer
- Retailer app scans the QR code
- QR code is converted back into string / ID
- System fetches complete data from MongoDB
- Purchase is verified and completed instantly

### Benefits
- ‚úÖ **Paperless option** - Digital bill storage
- ‚úÖ **Quick verification** - Instant QR code scanning
- ‚úÖ **Error reduction** - OCR eliminates manual entry
- ‚úÖ **Flexible workflow** - Multiple input methods

---

## üîß Why Next.js?

We chose Next.js as our primary framework for several strategic reasons:

### Built by Vercel
- Industry-leading framework with strong community support
- Regular updates and cutting-edge features
- Production-ready out of the box

### Unified Frontend + Backend
- **API routes** handle lightweight backend logic
- Frontend and backend in the same project
- Simplified development workflow
- Reduced complexity for simple backend needs

### Performance & Developer Experience
- Server-side rendering (SSR) for better SEO
- Static site generation (SSG) for optimal performance
- Built-in optimization for images and assets
- Excellent developer tooling and hot reload

### Scalability
- Easy deployment on Vercel platform
- Automatic scaling capabilities
- Edge network support for global performance

---

## üìÖ Project Information

**Last Updated:** February 2, 2026  
**Team:** Team-12

---

##  Development Update ñ February 23, 2026

This section documents the frontend authentication redesign and the production-grade backend database architecture implementation completed today.

---

#  Frontend Authentication Flow Redesign (React + Vite)

###  Objective
Redesign the authentication flow to support dual signup pages (User + Admin) while maintaining a single unified login page.

---

##  Files Modified / Created

### 1 src/Pages/Login.jsx (Modified)
- Added navigation links:
  - **Create User Account**
  - **Create Admin Account**
- Preserved unified login logic so both roles authenticate from one centralized entry.
- Maintained premium UI styling (glassmorphism card, soft glow background).

---

### 2 src/Pages/UserSignup.jsx (New)
- Dedicated User Registration page.
- Fields:
  - Full Name
  - Email Address
  - Password
- Matches Login page aesthetic and design system.
- Currently includes mock redirect to /shop.

---

### 3 src/Pages/AdminSignup.jsx (New)
- Dedicated Admin Registration page.
- Fields:
  - Full Name
  - Email Address
  - Store Name
  - Password
- Matches Login page premium UI styling.
- Currently includes mock redirect to /admin/dashboard.

---

### 4 src/App.jsx (Modified)
- Imported UserSignup and AdminSignup.
- Registered new routes:
  - /signup/user
  - /signup/admin
- Integrated into main <Routes> tree.

---

#  Backend Database Architecture (Node.js + Mongoose)

###  Objective
Design and implement a production-ready, concurrency-safe, transaction-based database layer for the Inventory Management System.

All backend changes scoped within:

\:/CSI/Team-12/server/\

---

#  Database Models Implemented

---

## 1 server/models/User.js
- Strict required field validation.
- Email:
  - unique: true
  - Regex validation
  - Indexed
- Role enforced using enum:
  - ['admin', 'user']
- Designed to support dual signup flow securely.

---

## 2 server/models/Product.js
- Enforced:
  - price minimum = 0
  - stock minimum = 0
- Guaranteed SKU uniqueness via indexing.
- Default lowStockThreshold configured.
- Linked createdBy to User ObjectId.
- Prevents negative inventory states at schema level.

---

## 3 server/models/Sale.js
- Embedded items array containing:
  - productId
  - quantity
  - priceAtSale (Snapshot Pricing)
- Snapshot pricing ensures historical report accuracy even if product price changes later.
- Enforced sale status enum:
  - pending
  - completed
  - cancelled

---

## 4 server/models/Bill.js
- References Sale via ObjectId.
- Enforced unique, indexed qrString.
- Designed for QR + OCR validation workflow.

---

## 5 server/models/AuditLog.js
- Captures:
  - userId
  - ctionType
  - collectionName
  - documentId
  - previousData
  - 
ewData
- Applied compound indexing on:
  - userId
  - 	imestamp
- Designed for high-volume audit querying efficiency.

---

#  Concurrency & Transaction Services

##  server/services/saleService.js

###  educeStockAtomically()
Implements MongoDB atomic stock reduction using:

\indOneAndUpdate({ stock: { $gte: quantity } })\

Guarantees:
- No race-condition overselling
- Stock can never fall below zero
- Thread-safe atomic updates
- Multi-user safety under simultaneous requests

---

###  createSaleTransaction()
Wraps entire sale lifecycle inside:

\session.startTransaction()\

Operations included:

1. Stock reduction
2. Sale creation
3. Bill generation
4. Audit logging
5. Commit transaction

If any step fails:
- Executes session.abortTransaction()
- Prevents ghost transactions
- Prevents mismatched stock and financial records
- Ensures strict ACID-compliant behavior

---

#  Backend Architecture Documentation

##  server/README-backend.md
- Defined scalable folder structure:
  - models/
  - services/
  - controllers/
  - routes/
  - middlewares/
- Established separation of concerns:
  - Data Layer (Models)
  - Business Logic (Services)
  - API Layer (Controllers & Routes)
- Documented maintainability principles for future backend expansion.

---

#  Summary of Todays Achievements

- Implemented dual-role authentication UI.
- Designed strict database schema architecture.
- Enforced validation and indexing strategies.
- Implemented atomic concurrency-safe stock control.
- Built full transaction-based sale workflow.
- Structured backend using production engineering principles.
